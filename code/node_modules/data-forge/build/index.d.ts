export { Index, IIndex } from './lib/index';
export { Series, ISeries, SelectorWithIndexFn } from './lib/series';
export { DataFrame, IDataFrame } from './lib/dataframe';
import { Series, ISeries } from '.';
import { DataFrame, IDataFrame } from '.';
/**
 * Represents a field from a JavaScript object.
 */
export interface IFieldRecord {
    /**
     * The name of the field.
     */
    Field: string;
    /**
     * The value of the field.
     */
    Value: any;
}
/**
 * Convert a regular JavaScript obejct to a dataframe.
 * Each row in the dataframe represents a field from the object.
 *
 * @param obj - The JavaScript object to convert to a dataframe.
 *
 * @returns Returns a dataframe that lists the fields in the pass-in object.
 */
export declare function fromObject(obj: any): IDataFrame<number, IFieldRecord>;
/**
 * Deserialize a dataframe from a JSON text string.
 *
 * @param jsonTextString The JSON text to deserialize.
 *
 * @returns Returns a dataframe that has been deserialized from the JSON data.
 */
export declare function fromJSON(jsonTextString: string): IDataFrame<number, any>;
/**
 * Options for parsing CSV data.
 */
export interface ICSVOptions {
    /**
     * Optionally specifies the column names (when enabled, assumes that the header row is not read from the CSV data).
     * Default: undefined
     */
    columnNames?: Iterable<string>;
    /**
     * Automatically pick types based on what the value looks like.
     * Default: false.
     */
    dynamicTyping?: boolean;
    /**
     * Skip empty lines in the input.
     * Default: true
     */
    skipEmptyLines?: boolean;
}
/**
 * Deserialize a DataFrame from a CSV text string.
 *
 * @param csvTextString The CSV text to deserialize.
 * @param [config] Optional configuration options for parsing the CSV data.
 *
 * @returns Returns a dataframe that has been deserialized from the CSV data.
 */
export declare function fromCSV(csvTextString: string, config?: ICSVOptions): DataFrame<number, any>;
/**
 * Reads a file asynchonrously to a dataframe.
 */
export interface IAsyncFileReader {
    /**
     * Deserialize a CSV file to a DataFrame.
     * Returns a promise that later resolves to a DataFrame.
     *
     * @param [config] Optional configuration file for parsing.
     *
     * @returns Returns a promise of a dataframe loaded from the file.
     */
    parseCSV(config?: ICSVOptions): Promise<IDataFrame<number, any>>;
    /**
     * Deserialize a JSON file to a DataFrame.
     * Returns a promise that later resolves to a DataFrame.
     *
     * @returns Returns a promise of a dataframe loaded from the file.
     */
    parseJSON(): Promise<IDataFrame<number, any>>;
}
/**
 * Read a file asynchronously from the file system.
 * Works in Nodejs, doesn't work in the browser.
 *
 * @param filePath The path to the file to read.
 *
 * @returns Returns an object that represents the file. Use `parseCSV` or `parseJSON` to deserialize to a DataFrame.
 */
export declare function readFile(filePath: string): IAsyncFileReader;
/**
 * Reads a file synchonrously to a dataframe.
 */
export interface ISyncFileReader {
    /**
     * Deserialize a CSV file to a DataFrame.
     *
     * @param [config] Optional configuration file for parsing.
     *
     * @returns Returns a dataframe that was deserialized from the file.
     */
    parseCSV(config?: ICSVOptions): IDataFrame<number, any>;
    /**
     * Deserialize a JSON file to a DataFrame.
     *
     * @returns {DataFrame} Returns a dataframe that was deserialized from the file.
     */
    parseJSON(): IDataFrame<number, any>;
}
/**
 * Read a file synchronously from the file system.
 * Works in Nodejs, doesn't work in the browser.
 *
 * @param filePath The path to the file to read.
 *
 * @returns Returns an object that represents the file. Use `parseCSV` or `parseJSON` to deserialize to a DataFrame.
 */
export declare function readFileSync(filePath: string): ISyncFileReader;
declare const concat: typeof Series.concat;
/**
 * Concatenate multiple series into a single series.
 * THIS FUNCTION IS DEPRECATED. Instead use dataFrame.Series.concat.
 *
 * @param {array} series - Array of series to concatenate.
 *
 * @returns {Series} - Returns the single concatendated series.
 */
export { concat as concatSeries };
declare const zip: typeof Series.zip;
/**
 * Zip together multiple series to create a new series.
 * THIS FUNCTION IS DEPRECATED. Instead use dataFrame.Series.zip.
 *
 * @param {array} series - Array of series to zip together.
 * @param {function} selector - Selector function that produces a new series based on the input series.
 *
 * @returns {Series} Returns a single series that is the combination of multiple input series that have been 'zipped' together by the 'selector' function.
 */
export { zip as zipSeries };
/**
 * Generate a series from a range of numbers.
 *
 * @param start - The value of the first number in the range.
 * @param count - The number of sequential values in the range.
 *
 * @returns Returns a series with a sequence of generated values. The series contains 'count' values beginning at 'start'.
 */
export declare function range(start: number, count: number): ISeries<number, number>;
/**
 * Replicate a particular value N times to create a series.
 *
 * @param value The value to replicate.
 * @param count The number of times to replicate the value.
 *
 * @returns Returns a new series that contains N copies of the value.
 */
export declare function replicate<ValueT>(value: ValueT, count: number): ISeries<number, ValueT>;
/**
 * Generate a data-frame containing a matrix of values.
 *
 * @param numColumns - The number of columns in the data-frame.
 * @param numRows - The number of rows in the data-frame.
 * @param start - The starting value.
 * @param increment - The value to increment by for each new value.
 *
 * @returns Returns a dataframe that contains a matrix of generated values.
 */
export declare function matrix(numColumns: number, numRows: number, start: number, increment: number): IDataFrame<number, any>;
