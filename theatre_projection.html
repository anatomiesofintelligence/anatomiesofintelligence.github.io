---
layout: performance
permalink: theatre/kmeans2
---

<div id="categories" style="display:none">
All Categories:
{% assign sortedcats = site.categories | sort: '' %}
{% for cat in sortedcats %}
<br/><a href="{{ site.url }}{{ cat[0] }}">{{ cat[0] }}</a>
{% endfor %}
</div>

<div id="tags" style="display:none">
{% capture site_tags %}{% for tag in site.tags %}{{ tag[0] }}{% unless forloop.last %},{% endunless %}{% endfor %}{% endcapture %}
{% assign tag_words = site_tags | split:',' | sort %}
All Tags:
<br />{% for tag in tag_words %}"{{ tag }}", {% endfor %}
</div>

<script>
// ****Initialize the catalog****
var catalog = new Catalog();
var tag_weight, newexample;
</script>


{% for post in site.posts %}
{% assign post_id = post.title | slugify:"latin" %}
<div class="refs" id="{{ post_id }}">
  <a href="{{ post.url }}" onclick="openEntry('{{ post_id }}'); return false"><span style="display:none">{{ post.date | date: "%B %d, %Y" }}:</span>{{ post.title }}</a>
{% if post.layout == "image" %}<img height="100" width="auto" src="/img/{{ post.image }}"/>{% endif %}
<script>
newexample = new Entry("{{ post_id }}", "{{ post.url }}");
{% for tag in post.tags %}
{% assign idx = forloop.index | minus: 1 %}
tag_weight = ["{{ tag }}", {{ post.weights[idx] }}];
newexample.addTag(tag_weight);
{% endfor %}
catalog.addEntry(newexample);
</script>
</div>
{% endfor %}


<script>
// ***ADDITIONAL FUNCTIONS****

function clean_surface() { location.reload() };

// Get all entry divs, optionally by a specific cluster
function getEntryDivs(cluster=-1) {
  let result, classval;
  if(cluster == -1) {
    classval = "refs";
  } else {
    classval = "cluster"+cluster;
  }
  result = document.getElementsByClassName(classval);
  return result;
}

// Get all centroid divs
function getCentroidDivs() {
    return document.getElementsByClassName("centroid");
}

// Remove all centroids and randomize DIVs in the DOM
function randomize() {
  let centroids, entries;
  centroids = getCentroidDivs();
  for(let i = centroids.length-1; i >= 0; i--) {
    centroids[i].remove();
  }
  entries = getEntryDivs();
  for(let entry of entries) {
    entry.className = "refs"; // remove any cluster association
    entry.style.border = "none";
    entry.style.top = Math.floor(Math.random() * window.innerHeight) + 'px';
    entry.style.left = Math.floor(Math.random() * window.innerWidth) + 'px';
  }
}

function showPopup(url, name) {
  let win = window.open(url, name,'height=490,width=420,top=200,left=300,resizable=yes,scrollbars=yes,toolbar=no,location=no,status=no,menubar=no');
  if(window.focus) { win.focus() }
}


function openEntry(entryID) {
  let entry_url = catalog.allEntries[entryID].url;
  console.log("OPENING: " + entry_url + entryID);
  showPopup(entry_url, entryID);
}


// USAGE TESTS: (if these work then our code is more-or-less done)
// test the catalog & clustering libraries
function run_tests() {
  // Grab a couple entries to work with
  e1 = Object.values(catalog.allEntries)[0];
  e2 = Object.values(catalog.allEntries)[1];
  tagscut = ["models", "preparations", "aesthesis", "unknown"];
  options = {taglist: tagscut};

  // Test getting a FeatureVec from an Entry based on the tags we are cutting along.
  fv1 = e1.getFeatures(options);
  fv2 = e2.getFeatures(options);
  console.log("Features of",e1,"are",fv1);
  console.log("Features of",e2,"are",fv2);
  ex_as_feat = catalog.examplesAsFeatures(options);
  console.log("All entries as feature vectors based on the given cut:", ex_as_feat);

  // Test distance measurements.. right now we only have the Euclidean standard
  distance = Measures.euclidean(fv1, fv2, options); // distance from entry 1 to entry 2 based on our cut and euclidean measurement method
  console.log("Distance", e1.id, "to", e2.id, "=", distance);


  // Test some of the statistical functions used in the KMeans algorithm
  km = new KMeans(3, options);
  feature_avg = km.mean(easf);
  console.log("MEAN of features:", feature_avg);
  normalized = km.normalize(easf);
  console.log("NORMALIZED features:",normalized);
  denormalized = km.denormalize(normalized);
  console.log("DENORMALIZED features:",denormalized);
};


function randomColorString() {
  return ""+Math.round(Math.random() * 255)+", "+Math.round(Math.random() * 255)+", "+Math.round(Math.random() * 255);
}

function projectCatalog(projectionType, clusters, centroids, options) {
  let centroid_divs = [];
  let centroidnumber = 0;
  let borderColor, j=0;

  // TODO: add error checking for null values in the options dictionary
  let showBorders = options.showBorders;
  let borderAlpha = options.borderAlpha;
  let centroidSymbol = options.centroidSymbol;
  let priorityFeatures = options.prioritizeFeatures; // used in simple 2D to determine dimensions to plot
  let scaleDistance = options.scaleDistance; // used for radial density
  let featuresDefinition = options.featuresDefinition;

  // calculate priority dimensions from feature names
  let priorityDims = [], dim;
  for(let feature of priorityFeatures) {
    dim = featuresDefinition.indexOf(feature);
    if(dim != -1) {
      priorityDims.push(dim);
    } else {
      console.log("ERROR: Could not find priority feature named '"+feature+"'");
    }
  }
  if(priorityDims.length < 2) {
    priorityDims = [0,1]; // use first and second dimension by default
    console.log("WARNING: No priority features specified, using first and second features");
  }


  switch(projectionType) {
    case Projections.SIMPLE2D: // 2D projection just looks at the first two features..
      console.log("SIMPLE 2D PROJECTION");
      let dimX = priorityDims[0], dimY = priorityDims[1];

      for(let centroid of centroids) {
        newdiv = document.createElement("div");
        newdiv.id = centroid.example;
        newdiv.className = "centroid";
        newdiv.style.position = "absolute";
        // DEPENDS ON CENTROID X/Y VALUES
        newdiv.style.top = (centroid.features[priorityDims[0]] * window.innerHeight) + 'px';
        newdiv.style.left = (centroid.features[priorityDims[1]] * window.innerWidth) + 'px';

        // Centroid Color Calculation
        if(showBorders) {
          if(CLUSTER_COLORS.length > j) {
            borderColor = CLUSTER_COLORS[j];
          } else {
            borderColor = randomColorString();
            CLUSTER_COLORS.push(borderColor);
          }
          newdiv.style.color = "rgb("+borderColor+")";
          j++;
        }


        newdiv.appendChild(document.createTextNode(centroidSymbol));
        document.body.appendChild(newdiv);
        centroid_divs.push(newdiv);
        centroidnumber++;
      }

      for(var i = 0; i < centroid_divs.length; i++) {
        var x,y;
        var cdiv = centroid_divs[i];
        c = centroids[i];
        for(let j = 0; j < clusters[i].length; j++) {
          var entrydiv, item = clusters[i][j];
          entrydiv = document.querySelector("#"+item.entry.id);
          entrydiv.style.position = "absolute";
          entrydiv.className = "refs " + "cluster" + i;

          if(showBorders) {
            borderColor = CLUSTER_COLORS[i];
            entrydiv.style.border = "2px solid rgba(" + borderColor + ", " + borderAlpha + ")";
          }

          entrydiv.style.top = (item.features[priorityDims[0]] * window.innerHeight) + 'px';
          entrydiv.style.left = (item.features[priorityDims[1]] * window.innerWidth) + 'px';

        }
      }
    // END 2D PROJECTION
    break;
    case Projections.RADIUS: // no projection, use old circle layout
    default:
      console.log("NO PROJECTION");
      for(let centroid of centroids) {
          newdiv = document.createElement("div");
          newtext = document.createTextNode(centroidSymbol);
          newdiv.appendChild(newtext);
          newdiv.id = centroid.example;
          newdiv.className = "centroid";
          newdiv.style.position = "absolute";
          // Centroid Color Calculation
          if(showBorders) {
            if(CLUSTER_COLORS.length > j) {
              borderColor = CLUSTER_COLORS[j];
            } else {
              borderColor = randomColorString();
              CLUSTER_COLORS.push(borderColor);
            }
            newdiv.style.color = "rgb("+borderColor+")";
            j++;
          }
          newdiv.style.top = ((900 / 3) + 100) + 'px';
          newdiv.style.left = (centroidnumber * (3000 / centroids.length) + 300) + 'px';
          document.body.appendChild(newdiv);
          centroid_divs.push(newdiv);
          centroidnumber += 1;
      }

      for(let i = 0; i < centroid_divs.length; i++) {
          let x,y,theta,c, e, distance, cdiv = centroid_divs[i];
          c = centroids[i];
          for(let j = 0; j < clusters[i].length; j++) {
              var entrydiv, item = clusters[i][j];

              // Here is the projection math, converts a distance to a radius
              distance = Measures.euclidean(c, item);
              theta = j * (2 * Math.PI / clusters[i].length);
              // Convert polar to cartesian
              x = Math.floor(distance * Math.cos(theta) * scaleDistance);
              y = Math.floor(distance * Math.sin(theta) * scaleDistance);

              entrydiv = document.querySelector("#"+item.entry.id);
              entrydiv.style.position = "absolute";
              entrydiv.className = "refs " + "cluster" + i;
              if(showBorders) {
                borderColor = CLUSTER_COLORS[i];
                entrydiv.style.border = "2px solid rgba(" + borderColor + ", " + borderAlpha + ")";
              }
              entrydiv.style.top = y + 'px';
              entrydiv.style.left = x + 'px';
              cdiv.appendChild(entrydiv);

          }
      }
      // END CIRCLE PROJECTION
    };
}


// Callback responds to clustering results and redraws the HTML
function resultfunc(err, clusters, centroids, featuresDef) {

    let old_centroid_divs = document.getElementsByClassName("centroid");
    // getElementsByClassName returns an HTMLCollection, which is dynamically resized
    // thus we need to count backwards
    let olddiv;
    for(let i = old_centroid_divs.length - 1; i >= 0; i--) {
      olddiv = old_centroid_divs[i];
      console.log("REMOVED OLD CENTROID:",olddiv);
      olddiv.remove();
    }

    let opts = {
      showBorders: SHOW_BORDERS,
      borderAlpha: BORDER_ALPHA,
      centroidSymbol: CENTROID_SYMBOL,
      prioritizeFeatures: PROJECTION_DIMENSIONS,
      scaleDistance: RADIAL_DENSITY,
      featuresDefinition: featuresDef,
    };
    projectCatalog(PROJECTION_TYPE, clusters, centroids, opts);

};

function help() {
    let str = `
    clean_surface()
    randomize()
    DENSITY = 50
    ITERATIONS = 5
    MEASUREMENT = Measures.euclidean
    BREAKPOINTS = true
    CLUSTERS = 3
    TEMPO = 1.0
    catalog.allEntries
    options = {taglist: ["models", "preparations", "aesthesis"]}
    cut = ["models", "preparations", "aesthesis", "unknown"]
    e1 = catalog.allEntries.choose()
    e2 = catalog.allEntries.choose()
    fv1 = e1.getFeatures(options)
    fv2 = e2.getFeatures(options)
    catalog.entriesAsFeatures(options)
    catalog.allTags;
    catalog.cluster(3, Measures.euclidean, options["taglist"], 10, resultfunc, false);
    catalog.cluster(CLUSTERS, MEASUREMENT, cut, ITERATIONS, resultfunc, BREAKPOINTS, osc, console.log);
  `;
  console.log(str);

};

</script>


<script>
// ****COMMANDS***

randomize(); // randomize example divs

// 4-dimensional cut into an N-dimensional body
var cut = ["models", "preparations", "aesthesis", "unknown"];

// Test clustering with 3 clusters and 10 iterations
//catalog.cluster(3, Measures.euclidean, tagscut, 10, resultfunc);

// Clustering parameters
var ITERATIONS = 5;
var MEASUREMENT = Measures.euclidean;
var RESULTFUNC = resultfunc;
var CLUSTERS = 3;

// Algorithmic time parameters
var BREAKPOINTS = true;  // break the algorithm up into temporal chunks
var TEMPO = 1.0; // timescale/tempo speed of algorithm steps

// Visualization parameters
var PROJECTION_TYPE = Projections.SIMPLE2D;
var PROJECTION_DIMENSIONS = ["model", "aesthesis", "categorization"];
var BORDER_ALPHA = 0.5;
var CLUSTER_COLORS = [
  "255, 0, 0",
  "0, 255, 0",
  "0, 0, 255",
  "0, 157, 157",
  "243, 200, 1",
  "183, 1, 255",
  "58, 236, 3",
  "4, 221, 245",
  "243, 169, 10",
];
CENTROID_SYMBOL = "+";
var SHOW_BORDERS = true;
var RADIAL_DENSITY = 500; // used in the RADIAL projection


options = {taglist: ["models", "preparations", "aesthesis"]};

// Initialize the OSC connection to the SO_Server
var osc = new SimpleOSC("localhost", 8080);
osc.init(function() {
  // Put code here that needs to run once an OSC connection is established
  //catalog.cluster(CLUSTERS, MEASUREMENT, cut, ITERATIONS, resultfunc, BREAKPOINTS, osc, console.log);
});

</script>
